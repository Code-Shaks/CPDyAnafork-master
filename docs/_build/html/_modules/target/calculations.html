

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>target.calculations &mdash; CPDyAna 01-02-2024 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=18cd0f04"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            CPDyAna
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../target.html">Target Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#main-analysis-driver">Main Analysis Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#cpdyana-combined-molecular-dynamics-analysis-tool">CPDyAna â€“ Combined Molecular Dynamics Analysis Tool</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.CPDyAna.Job"><code class="docutils literal notranslate"><span class="pre">Job()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.CPDyAna.main"><code class="docutils literal notranslate"><span class="pre">main()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.CPDyAna.parser"><code class="docutils literal notranslate"><span class="pre">parser()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#key-functions">Key Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#data-processing">Data Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#general-data-processing-module-for-cpdyana">General Data Processing Module for CPDyAna</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.data_processing.data_evaluator"><code class="docutils literal notranslate"><span class="pre">data_evaluator()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.data_processing.find_terms"><code class="docutils literal notranslate"><span class="pre">find_terms()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.data_processing.segmenter_func"><code class="docutils literal notranslate"><span class="pre">segmenter_func()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#lammps-data-processing">LAMMPS Data Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#lammps-data-processing-module-for-cpdyana">LAMMPS Data Processing Module for CPDyAna</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.data_processing_lammps.calculate_time_window_lammps"><code class="docutils literal notranslate"><span class="pre">calculate_time_window_lammps()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.data_processing_lammps.data_evaluator_lammps"><code class="docutils literal notranslate"><span class="pre">data_evaluator_lammps()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.data_processing_lammps.detect_lammps_format"><code class="docutils literal notranslate"><span class="pre">detect_lammps_format()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.data_processing_lammps.find_terms_lammps"><code class="docutils literal notranslate"><span class="pre">find_terms_lammps()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.data_processing_lammps.is_lammps_simulation"><code class="docutils literal notranslate"><span class="pre">is_lammps_simulation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.data_processing_lammps.segmenter_func_lammps"><code class="docutils literal notranslate"><span class="pre">segmenter_func_lammps()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#input-output-operations">Input/Output Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#input-file-reader-module-for-cpdyana">Input File Reader Module for CPDyAna</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.detect_trajectory_format"><code class="docutils literal notranslate"><span class="pre">detect_trajectory_format()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.export_verification_trajectory"><code class="docutils literal notranslate"><span class="pre">export_verification_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.generate_analysis_recommendations"><code class="docutils literal notranslate"><span class="pre">generate_analysis_recommendations()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.has_type_column"><code class="docutils literal notranslate"><span class="pre">has_type_column()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.read_bomd_trajectory"><code class="docutils literal notranslate"><span class="pre">read_bomd_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.read_cel_file"><code class="docutils literal notranslate"><span class="pre">read_cel_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.read_evp_file"><code class="docutils literal notranslate"><span class="pre">read_evp_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.read_ion_file"><code class="docutils literal notranslate"><span class="pre">read_ion_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.read_ion_file_universal"><code class="docutils literal notranslate"><span class="pre">read_ion_file_universal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.read_lammps_trajectory"><code class="docutils literal notranslate"><span class="pre">read_lammps_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.input_reader.read_pos_file"><code class="docutils literal notranslate"><span class="pre">read_pos_file()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.get_indices"><code class="docutils literal notranslate"><span class="pre">get_indices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.get_position_indices"><code class="docutils literal notranslate"><span class="pre">get_position_indices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.get_thermo_props"><code class="docutils literal notranslate"><span class="pre">get_thermo_props()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.iter_lammps_dump"><code class="docutils literal notranslate"><span class="pre">iter_lammps_dump()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.pos_2_absolute"><code class="docutils literal notranslate"><span class="pre">pos_2_absolute()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.read_lammps_dump"><code class="docutils literal notranslate"><span class="pre">read_lammps_dump()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.read_positions_with_ase"><code class="docutils literal notranslate"><span class="pre">read_positions_with_ase()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.read_step_info"><code class="docutils literal notranslate"><span class="pre">read_step_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.read_xsf"><code class="docutils literal notranslate"><span class="pre">read_xsf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.write_grid"><code class="docutils literal notranslate"><span class="pre">write_grid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.io.write_xsf"><code class="docutils literal notranslate"><span class="pre">write_xsf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#supported-file-types">Supported File Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#core-calculations">Core Calculations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#calculations-module-for-cpdyana">Calculations Module for CPDyAna</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.calculations.calc_fft"><code class="docutils literal notranslate"><span class="pre">calc_fft()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.calculations.calc_msd_tracer"><code class="docutils literal notranslate"><span class="pre">calc_msd_tracer()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.calculations.calc_ngp_tracer"><code class="docutils literal notranslate"><span class="pre">calc_ngp_tracer()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.calculations.calculate_msd"><code class="docutils literal notranslate"><span class="pre">calculate_msd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.calculations.calculate_msd_lammps"><code class="docutils literal notranslate"><span class="pre">calculate_msd_lammps()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.calculations.calculate_msd_qe"><code class="docutils literal notranslate"><span class="pre">calculate_msd_qe()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.calculations.calculate_ngp"><code class="docutils literal notranslate"><span class="pre">calculate_ngp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.calculations.disp_sum"><code class="docutils literal notranslate"><span class="pre">disp_sum()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.calculations.msd_charged"><code class="docutils literal notranslate"><span class="pre">msd_charged()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.calculations.msd_tracer"><code class="docutils literal notranslate"><span class="pre">msd_tracer()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#analysis-types">Analysis Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#correlation-analysis">Correlation Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#correlation-analysis-module-for-cpdyana">Correlation Analysis Module for CPDyAna</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.correrelation_analysis.Van_Hove_distinct"><code class="docutils literal notranslate"><span class="pre">Van_Hove_distinct()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.correrelation_analysis.Van_Hove_self"><code class="docutils literal notranslate"><span class="pre">Van_Hove_self()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#correlation-types">Correlation Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#rdf-computation">RDF Computation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.compute_rdf.build_ase_trajectory"><code class="docutils literal notranslate"><span class="pre">build_ase_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.compute_rdf.build_bomd_trajectory"><code class="docutils literal notranslate"><span class="pre">build_bomd_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.compute_rdf.build_lammps_trajectory"><code class="docutils literal notranslate"><span class="pre">build_lammps_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.compute_rdf.compute_rdf"><code class="docutils literal notranslate"><span class="pre">compute_rdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.compute_rdf.main"><code class="docutils literal notranslate"><span class="pre">main()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#vaf-computation">VAF Computation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.compute_vaf.build_bomd_trajectory"><code class="docutils literal notranslate"><span class="pre">build_bomd_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.compute_vaf.build_trajectory"><code class="docutils literal notranslate"><span class="pre">build_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.compute_vaf.compute_vaf"><code class="docutils literal notranslate"><span class="pre">compute_vaf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.compute_vaf.convert_symbols_to_atomic_numbers"><code class="docutils literal notranslate"><span class="pre">convert_symbols_to_atomic_numbers()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.compute_vaf.finite_diff_velocities"><code class="docutils literal notranslate"><span class="pre">finite_diff_velocities()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#vdos-analysis">VDOS Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#plotting-and-visualization">Plotting and Visualization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#plotting-and-visualization-module-for-cpdyana">Plotting and Visualization Module for CPDyAna</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.centers_to_edges"><code class="docutils literal notranslate"><span class="pre">centers_to_edges()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.centers_to_edges_time"><code class="docutils literal notranslate"><span class="pre">centers_to_edges_time()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.int_or_float"><code class="docutils literal notranslate"><span class="pre">int_or_float()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.main"><code class="docutils literal notranslate"><span class="pre">main()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.msd_plot"><code class="docutils literal notranslate"><span class="pre">msd_plot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.msd_plot_lammps"><code class="docutils literal notranslate"><span class="pre">msd_plot_lammps()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.msd_plot_qe"><code class="docutils literal notranslate"><span class="pre">msd_plot_qe()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.ngp_plot"><code class="docutils literal notranslate"><span class="pre">ngp_plot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.parse_cli_args"><code class="docutils literal notranslate"><span class="pre">parse_cli_args()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.plot_angular_spec"><code class="docutils literal notranslate"><span class="pre">plot_angular_spec()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.plot_power_spectrum"><code class="docutils literal notranslate"><span class="pre">plot_power_spectrum()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.plot_rdf"><code class="docutils literal notranslate"><span class="pre">plot_rdf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.plot_vaf_isotropic"><code class="docutils literal notranslate"><span class="pre">plot_vaf_isotropic()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.plotting.van_hove_plot"><code class="docutils literal notranslate"><span class="pre">van_hove_plot()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#probability-density-analysis">Probability Density Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#probability-density-calculation-module-for-cpdyana">Probability Density Calculation Module for CPDyAna</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.probability_density.build_bomd_trajectory"><code class="docutils literal notranslate"><span class="pre">build_bomd_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.probability_density.build_lammps_trajectory"><code class="docutils literal notranslate"><span class="pre">build_lammps_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.probability_density.build_trajectory"><code class="docutils literal notranslate"><span class="pre">build_trajectory()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.probability_density.calculate_probability_density"><code class="docutils literal notranslate"><span class="pre">calculate_probability_density()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.probability_density.convert_symbols_to_atomic_numbers"><code class="docutils literal notranslate"><span class="pre">convert_symbols_to_atomic_numbers()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.probability_density.divide_chunks"><code class="docutils literal notranslate"><span class="pre">divide_chunks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.probability_density.main"><code class="docutils literal notranslate"><span class="pre">main()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.probability_density.parse_mask"><code class="docutils literal notranslate"><span class="pre">parse_mask()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#trajectory-utilities">Trajectory Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.trajectory.IncompatibleTrajectoriesException"><code class="docutils literal notranslate"><span class="pre">IncompatibleTrajectoriesException</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory"><code class="docutils literal notranslate"><span class="pre">Trajectory</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.atoms"><code class="docutils literal notranslate"><span class="pre">Trajectory.atoms</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.types"><code class="docutils literal notranslate"><span class="pre">Trajectory.types</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.nat"><code class="docutils literal notranslate"><span class="pre">Trajectory.nat</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.cell"><code class="docutils literal notranslate"><span class="pre">Trajectory.cell</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.nstep"><code class="docutils literal notranslate"><span class="pre">Trajectory.nstep</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.__init__"><code class="docutils literal notranslate"><span class="pre">Trajectory.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#id0"><code class="docutils literal notranslate"><span class="pre">Trajectory.atoms</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.calculate_velocities_from_positions"><code class="docutils literal notranslate"><span class="pre">Trajectory.calculate_velocities_from_positions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#id1"><code class="docutils literal notranslate"><span class="pre">Trajectory.cell</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.from_atoms"><code class="docutils literal notranslate"><span class="pre">Trajectory.from_atoms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_ase_trajectory"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_ase_trajectory()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_atom_types"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_atom_types()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_atoms"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_atoms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_cells"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_cells()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_forces"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_forces()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_indices_of_species"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_indices_of_species()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_positions"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_positions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_step_atoms"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_step_atoms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_stress"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_stress()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_timestep"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_timestep()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_types"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_types()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_velocities"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_velocities()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.get_volumes"><code class="docutils literal notranslate"><span class="pre">Trajectory.get_volumes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#id2"><code class="docutils literal notranslate"><span class="pre">Trajectory.nat</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.recenter"><code class="docutils literal notranslate"><span class="pre">Trajectory.recenter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.set_atom_types"><code class="docutils literal notranslate"><span class="pre">Trajectory.set_atom_types()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.set_atoms"><code class="docutils literal notranslate"><span class="pre">Trajectory.set_atoms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.set_cells"><code class="docutils literal notranslate"><span class="pre">Trajectory.set_cells()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.set_forces"><code class="docutils literal notranslate"><span class="pre">Trajectory.set_forces()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.set_positions"><code class="docutils literal notranslate"><span class="pre">Trajectory.set_positions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.set_pot_energies"><code class="docutils literal notranslate"><span class="pre">Trajectory.set_pot_energies()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.set_stress"><code class="docutils literal notranslate"><span class="pre">Trajectory.set_stress()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.set_timestep"><code class="docutils literal notranslate"><span class="pre">Trajectory.set_timestep()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.set_types"><code class="docutils literal notranslate"><span class="pre">Trajectory.set_types()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.trajectory.Trajectory.set_velocities"><code class="docutils literal notranslate"><span class="pre">Trajectory.set_velocities()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#id3"><code class="docutils literal notranslate"><span class="pre">Trajectory.types</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.trajectory.check_trajectory_compatibility"><code class="docutils literal notranslate"><span class="pre">check_trajectory_compatibility()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#general-utilities">General Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#utility-module-for-samos-package">Utility Module for SAMOS Package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray"><code class="docutils literal notranslate"><span class="pre">AttributedArray</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray._arrays"><code class="docutils literal notranslate"><span class="pre">AttributedArray._arrays</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray._attrs"><code class="docutils literal notranslate"><span class="pre">AttributedArray._attrs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray._nstep"><code class="docutils literal notranslate"><span class="pre">AttributedArray._nstep</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.__init__"><code class="docutils literal notranslate"><span class="pre">AttributedArray.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.get_array"><code class="docutils literal notranslate"><span class="pre">AttributedArray.get_array()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.get_arraynames"><code class="docutils literal notranslate"><span class="pre">AttributedArray.get_arraynames()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.get_attr"><code class="docutils literal notranslate"><span class="pre">AttributedArray.get_attr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.get_attrs"><code class="docutils literal notranslate"><span class="pre">AttributedArray.get_attrs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.load_file"><code class="docutils literal notranslate"><span class="pre">AttributedArray.load_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.nstep"><code class="docutils literal notranslate"><span class="pre">AttributedArray.nstep</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.remove_array"><code class="docutils literal notranslate"><span class="pre">AttributedArray.remove_array()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.rescale_array"><code class="docutils literal notranslate"><span class="pre">AttributedArray.rescale_array()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.save"><code class="docutils literal notranslate"><span class="pre">AttributedArray.save()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.set_array"><code class="docutils literal notranslate"><span class="pre">AttributedArray.set_array()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.utilities.AttributedArray.set_attr"><code class="docutils literal notranslate"><span class="pre">AttributedArray.set_attr()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.utilities.InputError"><code class="docutils literal notranslate"><span class="pre">InputError</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.utilities.apply_minimum_image"><code class="docutils literal notranslate"><span class="pre">apply_minimum_image()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.utilities.get_color"><code class="docutils literal notranslate"><span class="pre">get_color()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.utilities.get_terminal_width"><code class="docutils literal notranslate"><span class="pre">get_terminal_width()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#analysis-helpers">Analysis Helpers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.analysis.BaseAnalyzer"><code class="docutils literal notranslate"><span class="pre">BaseAnalyzer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.BaseAnalyzer.__init__"><code class="docutils literal notranslate"><span class="pre">BaseAnalyzer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.BaseAnalyzer.run"><code class="docutils literal notranslate"><span class="pre">BaseAnalyzer.run()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.BaseAnalyzer.set_trajectory"><code class="docutils literal notranslate"><span class="pre">BaseAnalyzer.set_trajectory()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.analysis.DynamicsAnalyzer"><code class="docutils literal notranslate"><span class="pre">DynamicsAnalyzer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.DynamicsAnalyzer.__init__"><code class="docutils literal notranslate"><span class="pre">DynamicsAnalyzer.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.DynamicsAnalyzer.get_kinetic_energies"><code class="docutils literal notranslate"><span class="pre">DynamicsAnalyzer.get_kinetic_energies()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.DynamicsAnalyzer.get_power_spectrum"><code class="docutils literal notranslate"><span class="pre">DynamicsAnalyzer.get_power_spectrum()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.DynamicsAnalyzer.get_species_of_interest"><code class="docutils literal notranslate"><span class="pre">DynamicsAnalyzer.get_species_of_interest()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.DynamicsAnalyzer.get_vaf"><code class="docutils literal notranslate"><span class="pre">DynamicsAnalyzer.get_vaf()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.DynamicsAnalyzer.set_species_of_interest"><code class="docutils literal notranslate"><span class="pre">DynamicsAnalyzer.set_species_of_interest()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.DynamicsAnalyzer.set_trajectories"><code class="docutils literal notranslate"><span class="pre">DynamicsAnalyzer.set_trajectories()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.analysis.DynamicsAnalyzer.set_verbosity"><code class="docutils literal notranslate"><span class="pre">DynamicsAnalyzer.set_verbosity()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.analysis.TimeSeries"><code class="docutils literal notranslate"><span class="pre">TimeSeries</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.analysis.get_gaussian_density"><code class="docutils literal notranslate"><span class="pre">get_gaussian_density()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#target.analysis.write_xsf_header"><code class="docutils literal notranslate"><span class="pre">write_xsf_header()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#preprocessing">Preprocessing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../target.html#utility-modules">Utility Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#module-target.json_serializable">JSON Serialization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#json-serialization-utilities-for-cpdyana">JSON Serialization Utilities for CPDyAna</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#target.json_serializable.convert_to_serializable"><code class="docutils literal notranslate"><span class="pre">convert_to_serializable()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../target.html#module-target.const">Constants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../target.html#physical-constants-and-unit-conversions-for-cpdyana">Physical Constants and Unit Conversions for CPDyAna</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usage_Examples.html">Usage Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../usage_Examples.html#command-line-interface-examples">Command-Line Interface Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#mean-square-displacement-msd">Mean Square Displacement (MSD)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#non-gaussian-parameter-ngp">Non-Gaussian Parameter (NGP)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#van-hove-correlation-functions">Van Hove Correlation Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#radial-distribution-functions-rdf">Radial Distribution Functions (RDF)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#ionic-density-mapping">Ionic Density Mapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#velocity-autocorrelation-functions-vaf">Velocity Autocorrelation Functions (VAF)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#vibrational-density-of-states-vdos">Vibrational Density of States (VDOS)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../usage_Examples.html#python-api-examples">Python API Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#direct-function-usage">Direct Function Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#samos-module-integration">SAMOS Module Integration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../usage_Examples.html#batch-processing-workflows">Batch Processing Workflows</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#processing-multiple-simulations">Processing Multiple Simulations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#temperature-series-analysis">Temperature Series Analysis</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../usage_Examples.html#advanced-analysis-examples">Advanced Analysis Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#custom-van-hove-analysis">Custom Van Hove Analysis</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../usage_Examples.html#file-format-tips">File Format Tips</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#required-file-structure">Required File Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usage_Examples.html#performance-optimization">Performance Optimization</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Module Index:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Usage Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#basic-msd-analysis">Basic MSD Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#non-gaussian-parameter-ngp-analysis">Non-Gaussian Parameter (NGP) Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#van-hove-correlation-function">Van Hove Correlation Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#radial-distribution-function-rdf">Radial Distribution Function (RDF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#velocity-autocorrelation-function-vaf">Velocity Autocorrelation Function (VAF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#vibrational-density-of-states-vdos">Vibrational Density of States (VDOS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#ionic-density-mapping">Ionic Density Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../modules.html#batch-processing-workflows">Batch Processing Workflows</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../modules.html#processing-multiple-simulations">Processing Multiple Simulations</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">CPDyAna</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">target.calculations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for target.calculations</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Calculations Module for CPDyAna</span>
<span class="sd">===============================</span>

<span class="sd">This module provides the core calculation functions for molecular dynamics analysis,</span>
<span class="sd">focusing on Mean Square Displacement (MSD) calculations, diffusion coefficient</span>
<span class="sd">determination, and Non-Gaussian Parameter (NGP) analysis for both tracer and collective diffusion.</span>

<span class="sd">The module implements efficient algorithms for:</span>
<span class="sd">- MSD calculation for individual and collective particle motion</span>
<span class="sd">- Linear regression analysis for diffusion coefficient extraction</span>
<span class="sd">- Multi-directional diffusivity analysis (X, Y, Z, XY, XZ, YZ, XYZ)</span>
<span class="sd">- Statistical block averaging for error estimation</span>
<span class="sd">- Non-Gaussian Parameter (NGP) calculation for dynamical heterogeneity</span>

<span class="sd">Functions:</span>
<span class="sd">    calculate_msd: Main MSD calculation orchestrator (LAMMPS and QE support)</span>
<span class="sd">    msd_tracer: Individual particle MSD calculation</span>
<span class="sd">    msd_charged: Collective/charged species MSD calculation</span>
<span class="sd">    calculate_ngp: Non-Gaussian Parameter calculation for tracer diffusion</span>

<span class="sd">Author: CPDyAna Development Team</span>
<span class="sd">Version: 06-25-2025</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">linregress</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span>

<span class="c1"># FFT-based MSD calculation</span>
<div class="viewcode-block" id="calc_fft">
<a class="viewcode-back" href="../../target.html#target.calculations.calc_fft">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_fft</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Efficiently compute the autocorrelation using FFT for MSD calculation.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (np.ndarray): 1D array of positions for a single coordinate.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Autocorrelation result for MSD computation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">PSD</span> <span class="o">=</span> <span class="n">F</span> <span class="o">*</span> <span class="n">F</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">PSD</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">[:</span><span class="n">N</span><span class="p">])</span><span class="o">.</span><span class="n">real</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span> <span class="o">/</span> <span class="n">n</span></div>


<span class="c1"># Tracer MSD calculation helper</span>
<div class="viewcode-block" id="calc_msd_tracer">
<a class="viewcode-back" href="../../target.html#target.calculations.calc_msd_tracer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_msd_tracer</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate MSD for a single particle trajectory using an efficient algorithm.</span>

<span class="sd">    Args:</span>
<span class="sd">        r (np.ndarray): Trajectory array (steps, 3) for one particle.</span>
<span class="sd">        d_idx (np.ndarray): Array of time lag indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (MSD array for selected lags, MSD array per dimension for selected lags)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">step</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">r_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">r_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_sq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">part1_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
    <span class="n">r_sq_sum</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r_sq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">step</span><span class="p">):</span>
        <span class="n">r_sq_sum</span> <span class="o">-=</span> <span class="n">r_sq</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">r_sq</span><span class="p">[</span><span class="n">step</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">part1_c</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_sq_sum</span> <span class="o">/</span> <span class="p">(</span><span class="n">step</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">part1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">part1_c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">part2_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">calc_fft</span><span class="p">(</span><span class="n">r</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
    <span class="n">part2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">part2_c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">part1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">part2</span><span class="p">)[</span><span class="n">d_idx</span><span class="p">],</span> <span class="p">(</span><span class="n">part1_c</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">part2_c</span><span class="p">)[:,</span> <span class="n">d_idx</span><span class="p">]</span></div>


<div class="viewcode-block" id="msd_tracer">
<a class="viewcode-back" href="../../target.html#target.calculations.msd_tracer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">msd_tracer</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate average tracer MSD for all mobile ions.</span>

<span class="sd">    Args:</span>
<span class="sd">        structure (np.ndarray): Array of shape (num_mobile_ions, steps, 3).</span>
<span class="sd">        step (int): Number of time steps.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Average tracer MSD over all ions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_mobile_ions</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">msd_ions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">))])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_mobile_ions</span><span class="p">):</span>
        <span class="n">msd_i</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">calc_msd_tracer</span><span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">msd_ions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msd_ions</span><span class="p">,</span> <span class="n">msd_i</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">msd_ions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="msd_charged">
<a class="viewcode-back" href="../../target.html#target.calculations.msd_charged">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">msd_charged</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">final_msd</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the charged MSD for a given 3D position array and tracer MSD.</span>

<span class="sd">    Args:</span>
<span class="sd">        structure (np.ndarray): Array of shape (num_mobile_ions, steps, 3).</span>
<span class="sd">        final_msd (np.ndarray): Tracer MSD array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Charged MSD values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_mobile_ions</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">MSD_charged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">delt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
        <span class="n">MSD_charged</span><span class="p">[</span><span class="n">delt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">disp_sum</span><span class="p">(</span><span class="n">delt</span><span class="p">,</span> <span class="n">structure</span><span class="p">)</span> <span class="o">-</span>
                               <span class="n">final_msd</span><span class="p">[</span><span class="n">delt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_mobile_ions</span> <span class="o">*</span> <span class="p">(</span><span class="n">steps</span> <span class="o">-</span> <span class="n">delt</span><span class="p">))</span> <span class="o">/</span> \
                              <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">num_mobile_ions</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_mobile_ions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">steps</span> <span class="o">-</span> <span class="n">delt</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">MSD_charged</span></div>


<div class="viewcode-block" id="disp_sum">
<a class="viewcode-back" href="../../target.html#target.calculations.disp_sum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">disp_sum</span><span class="p">(</span><span class="n">delt</span><span class="p">,</span> <span class="n">mobile_ion_pos</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the sum of squared displacements for a given time delta.</span>

<span class="sd">    Args:</span>
<span class="sd">        delt (int): Time step difference.</span>
<span class="sd">        mobile_ion_pos (np.ndarray): Array of shape (num_mobile_ions, steps, 3).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Sum of squared displacements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mobile_ion_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">delt</span><span class="p">)</span>
    <span class="n">displacements</span> <span class="o">=</span> <span class="n">mobile_ion_pos</span><span class="p">[:,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">delt</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">mobile_ion_pos</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">displacements</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span></div>


<div class="viewcode-block" id="calculate_msd_lammps">
<a class="viewcode-back" href="../../target.html#target.calculations.calculate_msd_lammps">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_msd_lammps</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">diffusivity_direction_choices</span><span class="p">,</span> <span class="n">diffusivity_choices</span><span class="p">,</span>
                         <span class="n">pos_full</span><span class="p">,</span> <span class="n">conduct_rectified_structure_array</span><span class="p">,</span> <span class="n">conduct_ions_array</span><span class="p">,</span>
                         <span class="n">t</span><span class="p">,</span> <span class="n">Last_term</span><span class="p">,</span> <span class="n">initial_slope_time</span><span class="p">,</span> <span class="n">final_slope_time</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
                         <span class="n">dt_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">lammps_units</span><span class="o">=</span><span class="s2">&quot;metal&quot;</span><span class="p">,</span> <span class="n">atom_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_param_full</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate MSD and diffusivity for LAMMPS-style trajectory data.</span>

<span class="sd">    Args:</span>
<span class="sd">        elements (list): List of diffusing elements.</span>
<span class="sd">        diffusivity_direction_choices (list): Directions for analysis.</span>
<span class="sd">        diffusivity_choices (list): Types of diffusivity (&#39;Tracer&#39;, &#39;Charged&#39;, etc.).</span>
<span class="sd">        pos_full, conduct_rectified_structure_array, conduct_ions_array: Trajectory and ion data.</span>
<span class="sd">        t (np.ndarray): Time array.</span>
<span class="sd">        Last_term (int): Last index for analysis.</span>
<span class="sd">        initial_slope_time (float): Start time for slope fitting.</span>
<span class="sd">        final_slope_time (float): End time for slope fitting.</span>
<span class="sd">        block (int): Block size for error estimation.</span>
<span class="sd">        dt_value (float): Time step value.</span>
<span class="sd">        lammps_units (str): LAMMPS units.</span>
<span class="sd">        atom_types, cell_param_full: Optional atom/cell info.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Nested dictionary with MSD, diffusivity, and error estimates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">n_frames</span> <span class="o">=</span> <span class="n">conduct_rectified_structure_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conduct_rectified_structure_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">dt_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_frames</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt_value</span>

    <span class="k">for</span> <span class="n">ele_idx</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">direction_idx</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diffusivity_direction_choices</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;XYZ&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;XY&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;YZ&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;ZX&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}[</span><span class="n">direction</span><span class="p">]</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;XYZ&#39;</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conduct_rectified_structure_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">posit</span> <span class="o">=</span> <span class="n">conduct_rectified_structure_array</span><span class="p">[</span><span class="n">direction_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">posit</span> <span class="o">=</span> <span class="n">conduct_rectified_structure_array</span>
            <span class="n">step_counts</span> <span class="o">=</span> <span class="n">posit</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">diff_type_idx</span><span class="p">,</span> <span class="n">diff_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diffusivity_choices</span><span class="p">):</span>
                <span class="n">key_msd</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">_msd_array</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">key_time</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">_time_array</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">key_diffusivity</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">_diffusivity</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">key_diffusivity_error</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">_diffusivity_error</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">key_slope_sem</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">_slope_sem</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="c1"># MSD calculation for each type</span>
                <span class="k">if</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="s2">&quot;Tracer&quot;</span><span class="p">:</span>
                    <span class="n">msd_array</span> <span class="o">=</span> <span class="n">msd_tracer</span><span class="p">(</span><span class="n">posit</span><span class="p">,</span> <span class="n">step_counts</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="s2">&quot;Charged&quot;</span> <span class="ow">or</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="s2">&quot;Collective&quot;</span><span class="p">:</span>
                    <span class="n">tracer_msd_array</span> <span class="o">=</span> <span class="n">msd_tracer</span><span class="p">(</span><span class="n">posit</span><span class="p">,</span> <span class="n">step_counts</span><span class="p">)</span>
                    <span class="n">msd_array</span> <span class="o">=</span> <span class="n">msd_charged</span><span class="p">(</span><span class="n">posit</span><span class="p">,</span> <span class="n">tracer_msd_array</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">time_array</span> <span class="o">=</span> <span class="n">dt_array</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">msd_array</span><span class="p">)]</span>
                <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key_msd</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msd_array</span><span class="p">)</span>
                <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key_time</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span>

                <span class="c1"># Linear regression for diffusivity</span>
                <span class="n">first_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time_array</span><span class="p">,</span> <span class="n">initial_slope_time</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
                <span class="n">last_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time_array</span><span class="p">,</span> <span class="n">final_slope_time</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">first_idx</span> <span class="o">&lt;</span> <span class="n">last_idx</span> <span class="ow">and</span> <span class="n">last_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">msd_array</span><span class="p">):</span>
                    <span class="n">fit_times</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[</span><span class="n">first_idx</span><span class="p">:</span><span class="n">last_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">fit_msd</span> <span class="o">=</span> <span class="n">msd_array</span><span class="p">[</span><span class="n">first_idx</span><span class="p">:</span><span class="n">last_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">slope</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="n">linregress</span><span class="p">(</span><span class="n">fit_times</span><span class="p">,</span> <span class="n">fit_msd</span><span class="p">)</span>
                    <span class="n">diffusivity</span> <span class="o">=</span> <span class="p">(</span><span class="n">slope</span> <span class="o">*</span> <span class="mf">1e-4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
                    <span class="n">diffusivity_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">std_err</span> <span class="o">*</span> <span class="mf">1e-4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">diffusivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">diffusivity_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="c1"># Block analysis for error estimation</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">block</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">step_counts</span> <span class="o">//</span> <span class="n">M</span>
                <span class="n">slope_blocks</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
                    <span class="n">t_start</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">M</span>
                    <span class="n">t_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">M</span>
                    <span class="k">if</span> <span class="n">t_end</span> <span class="o">&gt;</span> <span class="n">step_counts</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">pos_block</span> <span class="o">=</span> <span class="n">posit</span><span class="p">[:,</span> <span class="n">t_start</span><span class="p">:</span><span class="n">t_end</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">step_block</span> <span class="o">=</span> <span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span>
                    <span class="k">if</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="s2">&quot;Tracer&quot;</span><span class="p">:</span>
                        <span class="n">msd_block</span> <span class="o">=</span> <span class="n">msd_tracer</span><span class="p">(</span><span class="n">pos_block</span><span class="p">,</span> <span class="n">step_block</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="s2">&quot;Charged&quot;</span> <span class="ow">or</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="s2">&quot;Collective&quot;</span><span class="p">:</span>
                        <span class="n">tracer_msd_block</span> <span class="o">=</span> <span class="n">msd_tracer</span><span class="p">(</span><span class="n">pos_block</span><span class="p">,</span> <span class="n">step_block</span><span class="p">)</span>
                        <span class="n">msd_block</span> <span class="o">=</span> <span class="n">msd_charged</span><span class="p">(</span><span class="n">pos_block</span><span class="p">,</span> <span class="n">tracer_msd_block</span><span class="p">)</span>
                    <span class="n">dt_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">step_block</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt_value</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt_block</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">slope_block</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linregress</span><span class="p">(</span><span class="n">dt_block</span><span class="p">,</span> <span class="n">msd_block</span><span class="p">)</span>
                        <span class="n">slope_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope_block</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slope_blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">slope_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">slope_blocks</span><span class="p">)</span>
                    <span class="n">slope_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">slope_blocks</span><span class="p">)</span>
                    <span class="n">slope_sem</span> <span class="o">=</span> <span class="n">slope_std</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slope_blocks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slope_sem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key_diffusivity</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diffusivity</span><span class="p">)</span>
                <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key_diffusivity_error</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diffusivity_err</span><span class="p">)</span>
                <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key_slope_sem</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope_sem</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result_dict</span></div>


<div class="viewcode-block" id="calculate_msd_qe">
<a class="viewcode-back" href="../../target.html#target.calculations.calculate_msd_qe">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_msd_qe</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">diffusivity_direction_choices</span><span class="p">,</span> <span class="n">diffusivity_choices</span><span class="p">,</span>
                     <span class="n">pos_full</span><span class="p">,</span> <span class="n">conduct_rectified_structure_array</span><span class="p">,</span> <span class="n">conduct_ions_array</span><span class="p">,</span>
                     <span class="n">t</span><span class="p">,</span> <span class="n">Last_term</span><span class="p">,</span> <span class="n">initial_slope_time</span><span class="p">,</span> <span class="n">final_slope_time</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
                     <span class="n">atom_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_param_full</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate MSD and diffusivity for Quantum Espresso-style trajectory data.</span>

<span class="sd">    Args:</span>
<span class="sd">        elements (list): List of diffusing elements.</span>
<span class="sd">        diffusivity_direction_choices (list): Directions for analysis.</span>
<span class="sd">        diffusivity_choices (list): Types of diffusivity (&#39;Tracer&#39;, &#39;Charged&#39;).</span>
<span class="sd">        pos_full, conduct_rectified_structure_array, conduct_ions_array: Trajectory and ion data.</span>
<span class="sd">        t (np.ndarray): Time array.</span>
<span class="sd">        Last_term (int): Last index for analysis.</span>
<span class="sd">        initial_slope_time (float): Start time for slope fitting.</span>
<span class="sd">        final_slope_time (float): End time for slope fitting.</span>
<span class="sd">        block (int): Block size for error estimation.</span>
<span class="sd">        atom_types, cell_param_full: Optional atom/cell info.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Nested dictionary with MSD, diffusivity, and error estimates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">ele</span><span class="p">]</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">direction_idx</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diffusivity_direction_choices</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;XYZ&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;XY&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;YZ&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;ZX&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}[</span><span class="n">direction</span><span class="p">]</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;XYZ&#39;</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">posit</span> <span class="o">=</span> <span class="n">conduct_rectified_structure_array</span><span class="p">[</span><span class="n">direction_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">step_counts</span> <span class="o">=</span> <span class="n">posit</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">diff_type_idx</span><span class="p">,</span> <span class="n">diff_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diffusivity_choices</span><span class="p">):</span>
                <span class="n">key_msd</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">_msd_array</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">key_diff</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">_diffusivity</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">key_sem</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">_slope_sem</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">key_diff_err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">_diffusivity_error</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="c1"># MSD calculation for each type</span>
                <span class="k">if</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="s2">&quot;Tracer&quot;</span><span class="p">:</span>
                    <span class="n">msd_array</span> <span class="o">=</span> <span class="n">msd_tracer</span><span class="p">(</span><span class="n">posit</span><span class="p">,</span> <span class="n">step_counts</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="s2">&quot;Charged&quot;</span><span class="p">:</span>
                    <span class="n">tracer_msd</span> <span class="o">=</span> <span class="n">msd_tracer</span><span class="p">(</span><span class="n">posit</span><span class="p">,</span> <span class="n">step_counts</span><span class="p">)</span>
                    <span class="n">msd_array</span> <span class="o">=</span> <span class="n">msd_charged</span><span class="p">(</span><span class="n">posit</span><span class="p">,</span> <span class="n">tracer_msd</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown diffusivity type: </span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Linear regression for diffusivity</span>
                <span class="n">first_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">initial_slope_time</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
                <span class="n">last_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">final_slope_time</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">first_idx</span> <span class="o">&lt;=</span> <span class="n">last_idx</span><span class="p">:</span>
                    <span class="n">slope</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="n">linregress</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">first_idx</span><span class="p">:</span><span class="n">last_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">msd_array</span><span class="p">[</span><span class="n">first_idx</span><span class="p">:</span><span class="n">last_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">diffusivity</span> <span class="o">=</span> <span class="p">(</span><span class="n">slope</span> <span class="o">*</span> <span class="mf">1e-4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">diffusivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">std_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="c1"># Block analysis for error estimation</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">block</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">step_counts</span> <span class="o">//</span> <span class="n">M</span>
                <span class="n">slope_blocks</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
                    <span class="n">t_start</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">M</span>
                    <span class="n">t_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">M</span>
                    <span class="k">if</span> <span class="n">t_end</span> <span class="o">&gt;</span> <span class="n">step_counts</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">pos_block</span> <span class="o">=</span> <span class="n">posit</span><span class="p">[:,</span> <span class="n">t_start</span><span class="p">:</span><span class="n">t_end</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">step_block</span> <span class="o">=</span> <span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span>
                    <span class="k">if</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="s2">&quot;Tracer&quot;</span><span class="p">:</span>
                        <span class="n">msd_block</span> <span class="o">=</span> <span class="n">msd_tracer</span><span class="p">(</span><span class="n">pos_block</span><span class="p">,</span> <span class="n">step_block</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="s2">&quot;Charged&quot;</span><span class="p">:</span>
                        <span class="n">tracer_msd_block</span> <span class="o">=</span> <span class="n">msd_tracer</span><span class="p">(</span><span class="n">pos_block</span><span class="p">,</span> <span class="n">step_block</span><span class="p">)</span>
                        <span class="n">msd_block</span> <span class="o">=</span> <span class="n">msd_charged</span><span class="p">(</span><span class="n">pos_block</span><span class="p">,</span> <span class="n">tracer_msd_block</span><span class="p">)</span>
                    <span class="n">dt_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">step_block</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt_block</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">slope_block</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linregress</span><span class="p">(</span><span class="n">dt_block</span><span class="p">,</span> <span class="n">msd_block</span><span class="p">)</span>
                        <span class="n">slope_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope_block</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slope_blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">slope_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">slope_blocks</span><span class="p">)</span>
                    <span class="n">slope_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">slope_blocks</span><span class="p">)</span>
                    <span class="n">slope_sem</span> <span class="o">=</span> <span class="n">slope_std</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slope_blocks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">diffusivity_block_mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">slope_mean</span> <span class="o">*</span> <span class="mf">1e-4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
                    <span class="n">diffusivity_sem</span> <span class="o">=</span> <span class="p">(</span><span class="n">slope_sem</span> <span class="o">*</span> <span class="mf">1e-4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">diffusivity_block_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">diffusivity_sem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">slope_sem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key_msd</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msd_array</span><span class="p">)</span>
                <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key_diff</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diffusivity</span><span class="p">)</span>
                <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key_sem</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope_sem</span> <span class="k">if</span> <span class="s1">&#39;slope_sem&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key_diff_err</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diffusivity_sem</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result_dict</span></div>


<div class="viewcode-block" id="calculate_msd">
<a class="viewcode-back" href="../../target.html#target.calculations.calculate_msd">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_msd</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">diffusivity_direction_choices</span><span class="p">,</span> <span class="n">diffusivity_choices</span><span class="p">,</span>
                  <span class="n">pos_full</span><span class="p">,</span> <span class="n">conduct_rectified_structure_array</span><span class="p">,</span> <span class="n">conduct_ions_array</span><span class="p">,</span>
                  <span class="n">t</span><span class="p">,</span> <span class="n">Last_term</span><span class="p">,</span> <span class="n">initial_slope_time</span><span class="p">,</span> <span class="n">final_slope_time</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
                  <span class="n">is_lammps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dt_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">lammps_units</span><span class="o">=</span><span class="s2">&quot;metal&quot;</span><span class="p">,</span> <span class="n">atom_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_param_full</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main orchestrator for MSD and diffusivity calculations.</span>

<span class="sd">    Args:</span>
<span class="sd">        elements (list): List of diffusing elements.</span>
<span class="sd">        diffusivity_direction_choices (list): Directions for analysis.</span>
<span class="sd">        diffusivity_choices (list): Types of diffusivity.</span>
<span class="sd">        pos_full, conduct_rectified_structure_array, conduct_ions_array: Trajectory and ion data.</span>
<span class="sd">        t (np.ndarray): Time array.</span>
<span class="sd">        Last_term (int): Last index for analysis.</span>
<span class="sd">        initial_slope_time (float): Start time for slope fitting.</span>
<span class="sd">        final_slope_time (float): End time for slope fitting.</span>
<span class="sd">        block (int): Block size for error estimation.</span>
<span class="sd">        is_lammps (bool): If True, use LAMMPS-style calculation.</span>
<span class="sd">        dt_value (float): Time step value for LAMMPS.</span>
<span class="sd">        lammps_units (str): LAMMPS units.</span>
<span class="sd">        atom_types, cell_param_full: Optional atom/cell info.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Nested dictionary with MSD, diffusivity, and error estimates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_lammps</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">calculate_msd_lammps</span><span class="p">(</span>
            <span class="n">elements</span><span class="p">,</span> <span class="n">diffusivity_direction_choices</span><span class="p">,</span> <span class="n">diffusivity_choices</span><span class="p">,</span>
            <span class="n">pos_full</span><span class="p">,</span> <span class="n">conduct_rectified_structure_array</span><span class="p">,</span> <span class="n">conduct_ions_array</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">Last_term</span><span class="p">,</span> <span class="n">initial_slope_time</span><span class="p">,</span> <span class="n">final_slope_time</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
            <span class="n">dt_value</span><span class="o">=</span><span class="n">dt_value</span><span class="p">,</span> <span class="n">lammps_units</span><span class="o">=</span><span class="n">lammps_units</span><span class="p">,</span> <span class="n">atom_types</span><span class="o">=</span><span class="n">atom_types</span><span class="p">,</span> <span class="n">cell_param_full</span><span class="o">=</span><span class="n">cell_param_full</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">calculate_msd_qe</span><span class="p">(</span>
            <span class="n">elements</span><span class="p">,</span> <span class="n">diffusivity_direction_choices</span><span class="p">,</span> <span class="n">diffusivity_choices</span><span class="p">,</span>
            <span class="n">pos_full</span><span class="p">,</span> <span class="n">conduct_rectified_structure_array</span><span class="p">,</span> <span class="n">conduct_ions_array</span><span class="p">,</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">Last_term</span><span class="p">,</span> <span class="n">initial_slope_time</span><span class="p">,</span> <span class="n">final_slope_time</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
            <span class="n">atom_types</span><span class="o">=</span><span class="n">atom_types</span><span class="p">,</span> <span class="n">cell_param_full</span><span class="o">=</span><span class="n">cell_param_full</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="calc_ngp_tracer">
<a class="viewcode-back" href="../../target.html#target.calculations.calc_ngp_tracer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_ngp_tracer</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">d_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Non-Gaussian Parameter (NGP) for tracer diffusion.</span>

<span class="sd">    Args:</span>
<span class="sd">        r (np.ndarray): Position array (time_steps, 3) for one particle.</span>
<span class="sd">        d (int): Dimensionality (1, 2, or 3).</span>
<span class="sd">        d_idx (np.ndarray): Array of time lag indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: NGP values for specified time lags.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ngp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d_idx</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">delta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d_idx</span><span class="p">):</span>
        <span class="n">disp</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">delta</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">r</span><span class="p">[:</span><span class="o">-</span><span class="n">delta</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">disp</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">r4</span> <span class="o">=</span> <span class="n">r2</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">mean_r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r2</span><span class="p">)</span>
        <span class="n">mean_r4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mean_r2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">numerator</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">mean_r4</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">mean_r2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ngp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ngp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">ngp</span></div>


<div class="viewcode-block" id="calculate_ngp">
<a class="viewcode-back" href="../../target.html#target.calculations.calculate_ngp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_ngp</span><span class="p">(</span><span class="n">diffusing_elements</span><span class="p">,</span> <span class="n">diffusivity_direction_choices</span><span class="p">,</span> <span class="n">pos_full</span><span class="p">,</span> 
                  <span class="n">conduct_rectified_structure_array</span><span class="p">,</span> <span class="n">conduct_ions_array</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> 
                  <span class="n">initial_time</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">final_time</span><span class="o">=</span><span class="mf">200.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Non-Gaussian Parameter (NGP) for specified elements and directions.</span>

<span class="sd">    Args:</span>
<span class="sd">        diffusing_elements (list): Elements to analyze (e.g., [&#39;Li&#39;]).</span>
<span class="sd">        diffusivity_direction_choices (list): Directions (e.g., [&#39;XYZ&#39;]).</span>
<span class="sd">        pos_full (np.ndarray): Full position trajectory.</span>
<span class="sd">        conduct_rectified_structure_array (np.ndarray): Unwrapped positions.</span>
<span class="sd">        conduct_ions_array (list): Ion indices.</span>
<span class="sd">        dt (np.ndarray): Time step array (ps).</span>
<span class="sd">        initial_time (float): Start time for analysis (ps).</span>
<span class="sd">        final_time (float): End time for analysis (ps).</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Nested dictionary with NGP and time lag data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">time_step</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">time_lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span> <span class="o">*</span> <span class="n">time_step</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_lags</span> <span class="o">&gt;=</span> <span class="n">initial_time</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">time_lags</span> <span class="o">&lt;=</span> <span class="n">final_time</span><span class="p">)</span>
    <span class="n">d_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">))[</span><span class="n">mask</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[DEBUG] d_idx for NGP: </span><span class="si">{</span><span class="n">d_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diffusing_elements</span><span class="p">)):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">diffusing_elements</span><span class="p">[</span><span class="n">ele</span><span class="p">]</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">direction_idx</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diffusivity_direction_choices</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;XYZ&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;XY&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;YZ&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;ZX&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}[</span><span class="n">direction</span><span class="p">]</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;XYZ&#39;</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">posit</span> <span class="o">=</span> <span class="n">conduct_rectified_structure_array</span><span class="p">[</span><span class="n">direction_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">step_counts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">posit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;posit shape for NGP: </span><span class="si">{</span><span class="n">posit</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;step_counts for NGP: </span><span class="si">{</span><span class="n">step_counts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">num_mobile_ions</span> <span class="o">=</span> <span class="n">posit</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Parallel calculation of NGP for all ions</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">ngp_ions</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">calc_ngp_tracer</span><span class="p">,</span> 
                                       <span class="p">[(</span><span class="n">posit</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">d</span><span class="p">,</span> <span class="n">d_idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_mobile_ions</span><span class="p">)])</span>
            <span class="n">ngp_ions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ngp_ions</span><span class="p">)</span>
            <span class="n">ngp_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ngp_ions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;NGP array length: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ngp_array</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dt length for NGP: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">key_ngp</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;NGP_array</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key_ngp</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ngp_array</span><span class="p">)</span>
            <span class="n">result_dict</span><span class="p">[</span><span class="n">element</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;time_lags&#39;</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time_lags</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">result_dict</span></div>


<span class="c1"># &quot;&quot;&quot;</span>
<span class="c1"># Calculations Module for CPDyAna</span>
<span class="c1"># ===============================</span>

<span class="c1"># This module provides the core calculation functions for molecular dynamics analysis,</span>
<span class="c1"># focusing on Mean Square Displacement (MSD) calculations, diffusion coefficient</span>
<span class="c1"># determination, and Non-Gaussian Parameter (NGP) analysis for both tracer and collective diffusion.</span>

<span class="c1"># The module implements efficient algorithms for:</span>
<span class="c1"># - MSD calculation for individual and collective particle motion</span>
<span class="c1"># - Linear regression analysis for diffusion coefficient extraction</span>
<span class="c1"># - Multi-directional diffusivity analysis (X, Y, Z, XY, XZ, YZ, XYZ)</span>
<span class="c1"># - Statistical block averaging for error estimation</span>
<span class="c1"># - Non-Gaussian Parameter (NGP) calculation for dynamical heterogeneity</span>

<span class="c1"># Functions:</span>
<span class="c1">#     calculate_msd: Main MSD calculation orchestrator (LAMMPS and QE support)</span>
<span class="c1">#     msd_tracer: Individual particle MSD calculation</span>
<span class="c1">#     msd_charged: Collective/charged species MSD calculation</span>
<span class="c1">#     calculate_ngp: Non-Gaussian Parameter calculation for tracer diffusion</span>
<span class="c1">#     msd_tracer_lazy: Lazy loading MSD calculation</span>
<span class="c1">#     calc_ngp_tracer_lazy: Lazy loading NGP calculation</span>

<span class="c1"># Author: CPDyAna Development Team</span>
<span class="c1"># Version: 06-25-2025</span>
<span class="c1"># &quot;&quot;&quot;</span>

<span class="c1"># import numpy as np</span>
<span class="c1"># from scipy.stats import linregress</span>
<span class="c1"># from multiprocessing import Pool</span>

<span class="c1"># # FFT-based MSD calculation</span>
<span class="c1"># def calc_fft(x):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Efficiently compute the autocorrelation using FFT for MSD calculation.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         x (np.ndarray): 1D array of positions for a single coordinate.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         np.ndarray: Autocorrelation result for MSD computation.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     N = x.shape[0]</span>
<span class="c1">#     F = np.fft.fft(x, n=2 * N)</span>
<span class="c1">#     PSD = F * F.conjugate()</span>
<span class="c1">#     res = np.fft.ifft(PSD)</span>
<span class="c1">#     res = (res[:N]).real</span>
<span class="c1">#     n = N * np.ones(N) - np.arange(N)</span>
<span class="c1">#     return res / n</span>

<span class="c1"># # Tracer MSD calculation helper</span>
<span class="c1"># def calc_msd_tracer(r, d_idx):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Calculate MSD for a single particle trajectory using an efficient algorithm.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         r (np.ndarray): Trajectory array (steps, 3) for one particle.</span>
<span class="c1">#         d_idx (np.ndarray): Array of time lag indices.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         tuple: (MSD array for selected lags, MSD array per dimension for selected lags)</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     step, dim = r.shape</span>
<span class="c1">#     r_sq = np.square(r)</span>
<span class="c1">#     r_sq = np.append(r_sq, np.zeros((1, 3)), axis=0)</span>
<span class="c1">#     part1_c = np.zeros((3, step))</span>
<span class="c1">#     r_sq_sum = 2 * np.sum(r_sq, axis=0)</span>
<span class="c1">#     for i in range(step):</span>
<span class="c1">#         r_sq_sum -= r_sq[i - 1, :] + r_sq[step - i, :]</span>
<span class="c1">#         part1_c[:, i] = r_sq_sum / (step - i)</span>
<span class="c1">#     part1 = np.sum(part1_c, axis=0)</span>
<span class="c1">#     part2_c = np.array([calc_fft(r[:, i]) for i in range(r.shape[1])])</span>
<span class="c1">#     part2 = np.sum(part2_c, axis=0)</span>
<span class="c1">#     return (part1 - 2 * part2)[d_idx], (part1_c - 2 * part2_c)[:, d_idx]</span>

<span class="c1"># # def msd_tracer(structure, step):</span>
<span class="c1"># #     &quot;&quot;&quot;</span>
<span class="c1"># #     Calculate average tracer MSD for all mobile ions.</span>

<span class="c1"># #     Args:</span>
<span class="c1"># #         structure (np.ndarray): Array of shape (num_mobile_ions, steps, 3).</span>
<span class="c1"># #         step (int): Number of time steps.</span>

<span class="c1"># #     Returns:</span>
<span class="c1"># #         np.ndarray: Average tracer MSD over all ions.</span>
<span class="c1"># #     &quot;&quot;&quot;</span>
<span class="c1"># #     num_mobile_ions = structure.shape[0]</span>
<span class="c1"># #     msd_ions = np.empty([0, len(np.arange(1, step, 1))])</span>
<span class="c1"># #     for i in range(num_mobile_ions):</span>
<span class="c1"># #         msd_i, _ = calc_msd_tracer(structure[i, :, :], np.arange(1, step, 1))</span>
<span class="c1"># #         msd_ions = np.append(msd_ions, msd_i.reshape(1, len(np.arange(1, step, 1))), axis=0)</span>
<span class="c1"># #     return np.average(msd_ions, axis=0)</span>

<span class="c1"># # def msd_charged(structure, final_msd):</span>
<span class="c1"># #     &quot;&quot;&quot;</span>
<span class="c1"># #     Calculate the charged MSD for a given 3D position array and tracer MSD.</span>

<span class="c1"># #     Args:</span>
<span class="c1"># #         structure (np.ndarray): Array of shape (num_mobile_ions, steps, 3).</span>
<span class="c1"># #         final_msd (np.ndarray): Tracer MSD array.</span>

<span class="c1"># #     Returns:</span>
<span class="c1"># #         np.ndarray: Charged MSD values.</span>
<span class="c1"># #     &quot;&quot;&quot;</span>
<span class="c1"># #     num_mobile_ions = structure.shape[0]</span>
<span class="c1"># #     steps = structure.shape[1]</span>
<span class="c1"># #     MSD_charged = np.zeros(steps - 1)</span>
<span class="c1"># #     for delt in range(1, steps):</span>
<span class="c1"># #         MSD_charged[delt-1] = (disp_sum(delt, structure) -</span>
<span class="c1"># #                                final_msd[delt-1] * num_mobile_ions * (steps - delt)) / \</span>
<span class="c1"># #                               (0.5 * num_mobile_ions * (num_mobile_ions - 1) * (steps - delt))</span>
<span class="c1"># #     return MSD_charged</span>

<span class="c1"># def disp_sum(delt, mobile_ion_pos):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Calculate the sum of squared displacements for a given time delta.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         delt (int): Time step difference.</span>
<span class="c1">#         mobile_ion_pos (np.ndarray): Array of shape (num_mobile_ions, steps, 3).</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         float: Sum of squared displacements.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     t = np.arange(mobile_ion_pos.shape[1] - delt)</span>
<span class="c1">#     displacements = mobile_ion_pos[:, t + delt, :] - mobile_ion_pos[:, t, :]</span>
<span class="c1">#     return np.sum(np.square(np.sum(np.abs(displacements), axis=0)))</span>

<span class="c1"># # --- LAZY LOADING VERSIONS ---</span>

<span class="c1"># def msd_tracer(frame_generator, n_atoms, max_lag=None):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Calculate average tracer MSD for all mobile ions using a frame generator.</span>
<span class="c1">#     Args:</span>
<span class="c1">#         frame_generator: yields frames with &#39;positions&#39; (n_atoms, 3)</span>
<span class="c1">#         n_atoms: number of mobile ions</span>
<span class="c1">#         max_lag: maximum lag time to compute MSD for (int)</span>
<span class="c1">#     Returns:</span>
<span class="c1">#         msd: np.ndarray of MSD values for each lag</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     # Store positions for each atom as a list of arrays</span>
<span class="c1">#     positions = [[] for _ in range(n_atoms)]</span>
<span class="c1">#     for frame in frame_generator:</span>
<span class="c1">#         pos = frame[&quot;positions&quot;]</span>
<span class="c1">#         for i in range(n_atoms):</span>
<span class="c1">#             positions[i].append(pos[i])</span>
<span class="c1">#     # Convert to arrays</span>
<span class="c1">#     positions = [np.array(p) for p in positions]</span>
<span class="c1">#     n_steps = len(positions[0])</span>
<span class="c1">#     if max_lag is None:</span>
<span class="c1">#         max_lag = n_steps - 1</span>
<span class="c1">#     msd = np.zeros(max_lag)</span>
<span class="c1">#     for lag in range(1, max_lag + 1):</span>
<span class="c1">#         msd_lag = []</span>
<span class="c1">#         for atom_pos in positions:</span>
<span class="c1">#             disp = atom_pos[lag:] - atom_pos[:-lag]</span>
<span class="c1">#             msd_lag.append(np.mean(np.sum(disp**2, axis=1)))</span>
<span class="c1">#         msd[lag - 1] = np.mean(msd_lag)</span>
<span class="c1">#     return msd</span>

<span class="c1"># def msd_charged(frame_generator, n_atoms, max_lag=None):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Calculate the charged MSD for a given frame generator (lazy loading).</span>
<span class="c1">#     Args:</span>
<span class="c1">#         frame_generator: yields frames with &#39;positions&#39; (n_atoms, 3)</span>
<span class="c1">#         n_atoms: number of mobile ions</span>
<span class="c1">#         max_lag: maximum lag time to compute MSD for (int)</span>
<span class="c1">#     Returns:</span>
<span class="c1">#         msd_charged: np.ndarray of charged MSD values for each lag</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     # Collect all positions as in the tracer version</span>
<span class="c1">#     positions = [[] for _ in range(n_atoms)]</span>
<span class="c1">#     for frame in frame_generator:</span>
<span class="c1">#         pos = frame[&quot;positions&quot;]</span>
<span class="c1">#         for i in range(n_atoms):</span>
<span class="c1">#             positions[i].append(pos[i])</span>
<span class="c1">#     positions = [np.array(p) for p in positions]</span>
<span class="c1">#     n_steps = len(positions[0])</span>
<span class="c1">#     if max_lag is None:</span>
<span class="c1">#         max_lag = n_steps - 1</span>

<span class="c1">#     msd_tracer = np.zeros(max_lag)</span>
<span class="c1">#     msd_charged = np.zeros(max_lag)</span>
<span class="c1">#     # Compute tracer MSD first</span>
<span class="c1">#     for lag in range(1, max_lag + 1):</span>
<span class="c1">#         msd_lag = []</span>
<span class="c1">#         for atom_pos in positions:</span>
<span class="c1">#             disp = atom_pos[lag:] - atom_pos[:-lag]</span>
<span class="c1">#             msd_lag.append(np.mean(np.sum(disp**2, axis=1)))</span>
<span class="c1">#         msd_tracer[lag - 1] = np.mean(msd_lag)</span>

<span class="c1">#     # Now compute charged MSD</span>
<span class="c1">#     for lag in range(1, max_lag + 1):</span>
<span class="c1">#         t = np.arange(n_steps - lag)</span>
<span class="c1">#         # Center of mass at each time</span>
<span class="c1">#         com_t = np.zeros((n_steps - lag, 3))</span>
<span class="c1">#         com_t_lag = np.zeros((n_steps - lag, 3))</span>
<span class="c1">#         for i in range(n_atoms):</span>
<span class="c1">#             com_t += positions[i][t]</span>
<span class="c1">#             com_t_lag += positions[i][t + lag]</span>
<span class="c1">#         com_t /= n_atoms</span>
<span class="c1">#         com_t_lag /= n_atoms</span>
<span class="c1">#         disp_com = com_t_lag - com_t</span>
<span class="c1">#         msd_com = np.mean(np.sum(disp_com**2, axis=1))</span>
<span class="c1">#         # Charged MSD formula</span>
<span class="c1">#         msd_charged[lag - 1] = (n_atoms * msd_com - msd_tracer[lag - 1]) / (n_atoms - 1) if n_atoms &gt; 1 else 0.0</span>

<span class="c1">#     return msd_charged</span>

<span class="c1"># def calc_ngp_tracer(frame_generator, n_atoms, max_lag=None):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Calculate Non-Gaussian Parameter (NGP) for tracer diffusion using a frame generator.</span>
<span class="c1">#     Args:</span>
<span class="c1">#         frame_generator: yields frames with &#39;positions&#39; (n_atoms, 3)</span>
<span class="c1">#         n_atoms: number of mobile ions</span>
<span class="c1">#         max_lag: maximum lag time to compute NGP for (int)</span>
<span class="c1">#     Returns:</span>
<span class="c1">#         ngp: np.ndarray of NGP values for each lag</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     positions = [[] for _ in range(n_atoms)]</span>
<span class="c1">#     for frame in frame_generator:</span>
<span class="c1">#         pos = frame[&quot;positions&quot;]</span>
<span class="c1">#         for i in range(n_atoms):</span>
<span class="c1">#             positions[i].append(pos[i])</span>
<span class="c1">#     positions = [np.array(p) for p in positions]</span>
<span class="c1">#     n_steps = len(positions[0])</span>
<span class="c1">#     if max_lag is None:</span>
<span class="c1">#         max_lag = n_steps - 1</span>
<span class="c1">#     ngp = np.zeros(max_lag)</span>
<span class="c1">#     d = 3  # dimensionality</span>
<span class="c1">#     for lag in range(1, max_lag + 1):</span>
<span class="c1">#         r2_all = []</span>
<span class="c1">#         r4_all = []</span>
<span class="c1">#         for atom_pos in positions:</span>
<span class="c1">#             disp = atom_pos[lag:] - atom_pos[:-lag]</span>
<span class="c1">#             r2 = np.sum(disp**2, axis=1)</span>
<span class="c1">#             r4 = r2**2</span>
<span class="c1">#             r2_all.append(r2)</span>
<span class="c1">#             r4_all.append(r4)</span>
<span class="c1">#         mean_r2 = np.mean(np.concatenate(r2_all))</span>
<span class="c1">#         mean_r4 = np.mean(np.concatenate(r4_all))</span>
<span class="c1">#         if mean_r2 &gt; 0:</span>
<span class="c1">#             numerator = d * mean_r4</span>
<span class="c1">#             denominator = (d + 2) * (mean_r2**2)</span>
<span class="c1">#             ngp[lag - 1] = (numerator / denominator) - 1</span>
<span class="c1">#         else:</span>
<span class="c1">#             ngp[lag - 1] = 0.0</span>
<span class="c1">#     return ngp</span>

<span class="c1"># # --- END LAZY LOADING VERSIONS ---</span>

<span class="c1"># def calculate_msd_lammps(elements, diffusivity_direction_choices, diffusivity_choices,</span>
<span class="c1">#                          pos_full, conduct_rectified_structure_array, conduct_ions_array,</span>
<span class="c1">#                          t, Last_term, initial_slope_time, final_slope_time, block,</span>
<span class="c1">#                          dt_value=1.0, lammps_units=&quot;metal&quot;, atom_types=None, cell_param_full=None):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Calculate MSD and diffusivity for LAMMPS-style trajectory data.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         elements (list): List of diffusing elements.</span>
<span class="c1">#         diffusivity_direction_choices (list): Directions for analysis.</span>
<span class="c1">#         diffusivity_choices (list): Types of diffusivity (&#39;Tracer&#39;, &#39;Charged&#39;, etc.).</span>
<span class="c1">#         pos_full, conduct_rectified_structure_array, conduct_ions_array: Trajectory and ion data.</span>
<span class="c1">#         t (np.ndarray): Time array.</span>
<span class="c1">#         Last_term (int): Last index for analysis.</span>
<span class="c1">#         initial_slope_time (float): Start time for slope fitting.</span>
<span class="c1">#         final_slope_time (float): End time for slope fitting.</span>
<span class="c1">#         block (int): Block size for error estimation.</span>
<span class="c1">#         dt_value (float): Time step value.</span>
<span class="c1">#         lammps_units (str): LAMMPS units.</span>
<span class="c1">#         atom_types, cell_param_full: Optional atom/cell info.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         dict: Nested dictionary with MSD, diffusivity, and error estimates.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     result_dict = {}</span>
<span class="c1">#     n_frames = conduct_rectified_structure_array.shape[2] if len(conduct_rectified_structure_array.shape) == 4 else len(t)</span>
<span class="c1">#     dt_array = np.arange(1, n_frames) * dt_value</span>

<span class="c1">#     for ele_idx, element in enumerate(elements):</span>
<span class="c1">#         result_dict[element] = {}</span>
<span class="c1">#         for direction_idx, direction in enumerate(diffusivity_direction_choices):</span>
<span class="c1">#             d = {&#39;XYZ&#39;: 3, &#39;XY&#39;: 2, &#39;YZ&#39;: 2, &#39;ZX&#39;: 2, &#39;X&#39;: 1, &#39;Y&#39;: 1, &#39;Z&#39;: 1}[direction]</span>
<span class="c1">#             suffix = &#39;&#39; if direction == &#39;XYZ&#39; else f&#39;_{direction}&#39;</span>
<span class="c1">#             if len(conduct_rectified_structure_array.shape) == 4:</span>
<span class="c1">#                 posit = conduct_rectified_structure_array[direction_idx, :, :, :]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 posit = conduct_rectified_structure_array</span>
<span class="c1">#             step_counts = posit.shape[1]</span>
<span class="c1">#             for diff_type_idx, diff_type in enumerate(diffusivity_choices):</span>
<span class="c1">#                 key_msd = f&quot;{diff_type}_msd_array{suffix}&quot;</span>
<span class="c1">#                 key_time = f&quot;{diff_type}_time_array{suffix}&quot;</span>
<span class="c1">#                 key_diffusivity = f&quot;{diff_type}_diffusivity{suffix}&quot;</span>
<span class="c1">#                 key_diffusivity_error = f&quot;{diff_type}_diffusivity_error{suffix}&quot;</span>
<span class="c1">#                 key_slope_sem = f&quot;{diff_type}_slope_sem{suffix}&quot;</span>

<span class="c1">#                 # MSD calculation for each type</span>
<span class="c1">#                 if diff_type == &quot;Tracer&quot;:</span>
<span class="c1">#                     msd_array = msd_tracer(posit, step_counts)</span>
<span class="c1">#                 elif diff_type == &quot;Charged&quot; or diff_type == &quot;Collective&quot;:</span>
<span class="c1">#                     tracer_msd_array = msd_tracer(posit, step_counts)</span>
<span class="c1">#                     msd_array = msd_charged(posit, tracer_msd_array)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     continue</span>

<span class="c1">#                 time_array = dt_array[:len(msd_array)]</span>
<span class="c1">#                 result_dict[element].setdefault(key_msd, []).append(msd_array)</span>
<span class="c1">#                 result_dict[element].setdefault(key_time, []).append(time_array)</span>

<span class="c1">#                 # Linear regression for diffusivity</span>
<span class="c1">#                 first_idx = np.searchsorted(time_array, initial_slope_time, side=&#39;left&#39;)</span>
<span class="c1">#                 last_idx = np.searchsorted(time_array, final_slope_time, side=&#39;right&#39;) - 1</span>
<span class="c1">#                 if first_idx &lt; last_idx and last_idx &lt; len(msd_array):</span>
<span class="c1">#                     fit_times = time_array[first_idx:last_idx + 1]</span>
<span class="c1">#                     fit_msd = msd_array[first_idx:last_idx + 1]</span>
<span class="c1">#                     slope, _, _, _, std_err = linregress(fit_times, fit_msd)</span>
<span class="c1">#                     diffusivity = (slope * 1e-4) / (2 * d)</span>
<span class="c1">#                     diffusivity_err = (std_err * 1e-4) / (2 * d)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     diffusivity = np.nan</span>
<span class="c1">#                     diffusivity_err = np.nan</span>

<span class="c1">#                 # Block analysis for error estimation</span>
<span class="c1">#                 M = block</span>
<span class="c1">#                 B = step_counts // M</span>
<span class="c1">#                 slope_blocks = []</span>
<span class="c1">#                 for b in range(B):</span>
<span class="c1">#                     t_start = b * M</span>
<span class="c1">#                     t_end = (b + 1) * M</span>
<span class="c1">#                     if t_end &gt; step_counts:</span>
<span class="c1">#                         break</span>
<span class="c1">#                     pos_block = posit[:, t_start:t_end, :]</span>
<span class="c1">#                     step_block = t_end - t_start</span>
<span class="c1">#                     if diff_type == &quot;Tracer&quot;:</span>
<span class="c1">#                         msd_block = msd_tracer(pos_block, step_block)</span>
<span class="c1">#                     elif diff_type == &quot;Charged&quot; or diff_type == &quot;Collective&quot;:</span>
<span class="c1">#                         tracer_msd_block = msd_tracer(pos_block, step_block)</span>
<span class="c1">#                         msd_block = msd_charged(pos_block, tracer_msd_block)</span>
<span class="c1">#                     dt_block = np.arange(1, step_block) * dt_value</span>
<span class="c1">#                     if len(dt_block) &gt;= 2:</span>
<span class="c1">#                         slope_block, _, _, _, _ = linregress(dt_block, msd_block)</span>
<span class="c1">#                         slope_blocks.append(slope_block)</span>
<span class="c1">#                 if len(slope_blocks) &gt; 1:</span>
<span class="c1">#                     slope_mean = np.mean(slope_blocks)</span>
<span class="c1">#                     slope_std = np.std(slope_blocks)</span>
<span class="c1">#                     slope_sem = slope_std / np.sqrt(len(slope_blocks) - 1)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     slope_sem = np.nan</span>

<span class="c1">#                 result_dict[element].setdefault(key_diffusivity, []).append(diffusivity)</span>
<span class="c1">#                 result_dict[element].setdefault(key_diffusivity_error, []).append(diffusivity_err)</span>
<span class="c1">#                 result_dict[element].setdefault(key_slope_sem, []).append(slope_sem)</span>
<span class="c1">#     return result_dict</span>

<span class="c1"># def calculate_msd_qe(elements, diffusivity_direction_choices, diffusivity_choices,</span>
<span class="c1">#                      pos_full, conduct_rectified_structure_array, conduct_ions_array,</span>
<span class="c1">#                      t, Last_term, initial_slope_time, final_slope_time, block,</span>
<span class="c1">#                      atom_types=None, cell_param_full=None):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Calculate MSD and diffusivity for Quantum Espresso-style trajectory data.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         elements (list): List of diffusing elements.</span>
<span class="c1">#         diffusivity_direction_choices (list): Directions for analysis.</span>
<span class="c1">#         diffusivity_choices (list): Types of diffusivity (&#39;Tracer&#39;, &#39;Charged&#39;).</span>
<span class="c1">#         pos_full, conduct_rectified_structure_array, conduct_ions_array: Trajectory and ion data.</span>
<span class="c1">#         t (np.ndarray): Time array.</span>
<span class="c1">#         Last_term (int): Last index for analysis.</span>
<span class="c1">#         initial_slope_time (float): Start time for slope fitting.</span>
<span class="c1">#         final_slope_time (float): End time for slope fitting.</span>
<span class="c1">#         block (int): Block size for error estimation.</span>
<span class="c1">#         atom_types, cell_param_full: Optional atom/cell info.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         dict: Nested dictionary with MSD, diffusivity, and error estimates.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     result_dict = {}</span>
<span class="c1">#     for ele in range(len(elements)):</span>
<span class="c1">#         element = elements[ele]</span>
<span class="c1">#         result_dict[element] = {}</span>
<span class="c1">#         for direction_idx, direction in enumerate(diffusivity_direction_choices):</span>
<span class="c1">#             d = {&#39;XYZ&#39;: 3, &#39;XY&#39;: 2, &#39;YZ&#39;: 2, &#39;ZX&#39;: 2, &#39;X&#39;: 1, &#39;Y&#39;: 1, &#39;Z&#39;: 1}[direction]</span>
<span class="c1">#             suffix = &#39;&#39; if direction == &#39;XYZ&#39; else f&#39;_{direction}&#39;</span>
<span class="c1">#             posit = conduct_rectified_structure_array[direction_idx, :, :, :]</span>
<span class="c1">#             step_counts = posit.shape[1]</span>
<span class="c1">#             for diff_type_idx, diff_type in enumerate(diffusivity_choices):</span>
<span class="c1">#                 key_msd = f&quot;{diff_type}_msd_array{suffix}&quot;</span>
<span class="c1">#                 key_diff = f&quot;{diff_type}_diffusivity{suffix}&quot;</span>
<span class="c1">#                 key_sem = f&quot;{diff_type}_slope_sem{suffix}&quot;</span>
<span class="c1">#                 key_diff_err = f&quot;{diff_type}_diffusivity_error{suffix}&quot;</span>

<span class="c1">#                 # MSD calculation for each type</span>
<span class="c1">#                 if diff_type == &quot;Tracer&quot;:</span>
<span class="c1">#                     msd_array = msd_tracer(posit, step_counts)</span>
<span class="c1">#                 elif diff_type == &quot;Charged&quot;:</span>
<span class="c1">#                     tracer_msd = msd_tracer(posit, step_counts)</span>
<span class="c1">#                     msd_array = msd_charged(posit, tracer_msd)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     raise ValueError(f&quot;Unknown diffusivity type: {diff_type}&quot;)</span>

<span class="c1">#                 # Linear regression for diffusivity</span>
<span class="c1">#                 first_idx = np.searchsorted(t[1:], initial_slope_time, side=&#39;left&#39;)</span>
<span class="c1">#                 last_idx = np.searchsorted(t[1:], final_slope_time, side=&#39;right&#39;) - 1</span>
<span class="c1">#                 if first_idx &lt;= last_idx:</span>
<span class="c1">#                     slope, _, _, _, std_err = linregress(t[1:][first_idx:last_idx + 1], msd_array[first_idx:last_idx + 1])</span>
<span class="c1">#                     diffusivity = (slope * 1e-4) / (2 * d)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     diffusivity = np.nan</span>
<span class="c1">#                     std_err = np.nan</span>

<span class="c1">#                 # Block analysis for error estimation</span>
<span class="c1">#                 M = block</span>
<span class="c1">#                 B = step_counts // M</span>
<span class="c1">#                 slope_blocks = []</span>
<span class="c1">#                 for b in range(B):</span>
<span class="c1">#                     t_start = b * M</span>
<span class="c1">#                     t_end = (b + 1) * M</span>
<span class="c1">#                     if t_end &gt; step_counts:</span>
<span class="c1">#                         break</span>
<span class="c1">#                     pos_block = posit[:, t_start:t_end, :]</span>
<span class="c1">#                     step_block = t_end - t_start</span>
<span class="c1">#                     if diff_type == &quot;Tracer&quot;:</span>
<span class="c1">#                         msd_block = msd_tracer(pos_block, step_block)</span>
<span class="c1">#                     elif diff_type == &quot;Charged&quot;:</span>
<span class="c1">#                         tracer_msd_block = msd_tracer(pos_block, step_block)</span>
<span class="c1">#                         msd_block = msd_charged(pos_block, tracer_msd_block)</span>
<span class="c1">#                     dt_block = np.arange(1, step_block) * (t[1] - t[0])</span>
<span class="c1">#                     if len(dt_block) &gt;= 2:</span>
<span class="c1">#                         slope_block, _, _, _, _ = linregress(dt_block, msd_block)</span>
<span class="c1">#                         slope_blocks.append(slope_block)</span>
<span class="c1">#                 if len(slope_blocks) &gt; 1:</span>
<span class="c1">#                     slope_mean = np.mean(slope_blocks)</span>
<span class="c1">#                     slope_std = np.std(slope_blocks)</span>
<span class="c1">#                     slope_sem = slope_std / np.sqrt(len(slope_blocks) - 1)</span>
<span class="c1">#                     diffusivity_block_mean = (slope_mean * 1e-4) / (2 * d)</span>
<span class="c1">#                     diffusivity_sem = (slope_sem * 1e-4) / (2 * d)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     diffusivity_block_mean = np.nan</span>
<span class="c1">#                     diffusivity_sem = np.nan</span>
<span class="c1">#                     slope_sem = np.nan</span>

<span class="c1">#                 result_dict[element].setdefault(key_msd, []).append(msd_array)</span>
<span class="c1">#                 result_dict[element].setdefault(key_diff, []).append(diffusivity)</span>
<span class="c1">#                 result_dict[element].setdefault(key_sem, []).append(slope_sem if &#39;slope_sem&#39; in locals() else np.nan)</span>
<span class="c1">#                 result_dict[element].setdefault(key_diff_err, []).append(diffusivity_sem)</span>
<span class="c1">#     return result_dict</span>

<span class="c1"># def calculate_msd(elements, diffusivity_direction_choices, diffusivity_choices,</span>
<span class="c1">#                   pos_full, conduct_rectified_structure_array, conduct_ions_array,</span>
<span class="c1">#                   t, Last_term, initial_slope_time, final_slope_time, block,</span>
<span class="c1">#                   is_lammps=False, dt_value=1.0, lammps_units=&quot;metal&quot;, atom_types=None, cell_param_full=None):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Main orchestrator for MSD and diffusivity calculations.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         elements (list): List of diffusing elements.</span>
<span class="c1">#         diffusivity_direction_choices (list): Directions for analysis.</span>
<span class="c1">#         diffusivity_choices (list): Types of diffusivity.</span>
<span class="c1">#         pos_full, conduct_rectified_structure_array, conduct_ions_array: Trajectory and ion data.</span>
<span class="c1">#         t (np.ndarray): Time array.</span>
<span class="c1">#         Last_term (int): Last index for analysis.</span>
<span class="c1">#         initial_slope_time (float): Start time for slope fitting.</span>
<span class="c1">#         final_slope_time (float): End time for slope fitting.</span>
<span class="c1">#         block (int): Block size for error estimation.</span>
<span class="c1">#         is_lammps (bool): If True, use LAMMPS-style calculation.</span>
<span class="c1">#         dt_value (float): Time step value for LAMMPS.</span>
<span class="c1">#         lammps_units (str): LAMMPS units.</span>
<span class="c1">#         atom_types, cell_param_full: Optional atom/cell info.</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         dict: Nested dictionary with MSD, diffusivity, and error estimates.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     if is_lammps:</span>
<span class="c1">#         return calculate_msd_lammps(</span>
<span class="c1">#             elements, diffusivity_direction_choices, diffusivity_choices,</span>
<span class="c1">#             pos_full, conduct_rectified_structure_array, conduct_ions_array,</span>
<span class="c1">#             t, Last_term, initial_slope_time, final_slope_time, block,</span>
<span class="c1">#             dt_value=dt_value, lammps_units=lammps_units, atom_types=atom_types, cell_param_full=cell_param_full</span>
<span class="c1">#         )</span>
<span class="c1">#     else:</span>
<span class="c1">#         return calculate_msd_qe(</span>
<span class="c1">#             elements, diffusivity_direction_choices, diffusivity_choices,</span>
<span class="c1">#             pos_full, conduct_rectified_structure_array, conduct_ions_array,</span>
<span class="c1">#             t, Last_term, initial_slope_time, final_slope_time, block,</span>
<span class="c1">#             atom_types=atom_types, cell_param_full=cell_param_full</span>
<span class="c1">#         )</span>

<span class="c1"># # def calc_ngp_tracer(r, d, d_idx):</span>
<span class="c1"># #     &quot;&quot;&quot;</span>
<span class="c1"># #     Calculate Non-Gaussian Parameter (NGP) for tracer diffusion.</span>

<span class="c1"># #     Args:</span>
<span class="c1"># #         r (np.ndarray): Position array (time_steps, 3) for one particle.</span>
<span class="c1"># #         d (int): Dimensionality (1, 2, or 3).</span>
<span class="c1"># #         d_idx (np.ndarray): Array of time lag indices.</span>

<span class="c1"># #     Returns:</span>
<span class="c1"># #         np.ndarray: NGP values for specified time lags.</span>
<span class="c1"># #     &quot;&quot;&quot;</span>
<span class="c1"># #     step = r.shape[0]</span>
<span class="c1"># #     ngp = np.zeros(len(d_idx))</span>
<span class="c1"># #     for i, delta in enumerate(d_idx):</span>
<span class="c1"># #         disp = r[delta:, :] - r[:-delta, :]</span>
<span class="c1"># #         r2 = np.sum(disp**2, axis=1)</span>
<span class="c1"># #         r4 = r2**2</span>
<span class="c1"># #         mean_r2 = np.mean(r2)</span>
<span class="c1"># #         mean_r4 = np.mean(r4)</span>
<span class="c1"># #         if mean_r2 &gt; 0:</span>
<span class="c1"># #             numerator = d * mean_r4</span>
<span class="c1"># #             denominator = (d + 2) * (mean_r2**2)</span>
<span class="c1"># #             ngp[i] = (numerator / denominator) - 1</span>
<span class="c1"># #         else:</span>
<span class="c1"># #             ngp[i] = 0.0</span>
<span class="c1"># #     return ngp</span>

<span class="c1"># def calculate_ngp(diffusing_elements, diffusivity_direction_choices, pos_full, </span>
<span class="c1">#                   conduct_rectified_structure_array, conduct_ions_array, dt, </span>
<span class="c1">#                   initial_time=2.0, final_time=200.0):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Calculate Non-Gaussian Parameter (NGP) for specified elements and directions.</span>

<span class="c1">#     Args:</span>
<span class="c1">#         diffusing_elements (list): Elements to analyze (e.g., [&#39;Li&#39;]).</span>
<span class="c1">#         diffusivity_direction_choices (list): Directions (e.g., [&#39;XYZ&#39;]).</span>
<span class="c1">#         pos_full (np.ndarray): Full position trajectory.</span>
<span class="c1">#         conduct_rectified_structure_array (np.ndarray): Unwrapped positions.</span>
<span class="c1">#         conduct_ions_array (list): Ion indices.</span>
<span class="c1">#         dt (np.ndarray): Time step array (ps).</span>
<span class="c1">#         initial_time (float): Start time for analysis (ps).</span>
<span class="c1">#         final_time (float): End time for analysis (ps).</span>

<span class="c1">#     Returns:</span>
<span class="c1">#         dict: Nested dictionary with NGP and time lag data.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     result_dict = {}</span>
<span class="c1">#     time_step = dt[1] - dt[0]</span>
<span class="c1">#     time_lags = np.arange(1, len(dt)) * time_step</span>
<span class="c1">#     mask = (time_lags &gt;= initial_time) &amp; (time_lags &lt;= final_time)</span>
<span class="c1">#     d_idx = np.arange(1, len(dt))[mask]</span>
<span class="c1">#     print(f&quot;[DEBUG] d_idx for NGP: {d_idx}&quot;)</span>

<span class="c1">#     for ele in range(len(diffusing_elements)):</span>
<span class="c1">#         element = diffusing_elements[ele]</span>
<span class="c1">#         result_dict[element] = {}</span>

<span class="c1">#         for direction_idx, direction in enumerate(diffusivity_direction_choices):</span>
<span class="c1">#             d = {&#39;XYZ&#39;: 3, &#39;XY&#39;: 2, &#39;YZ&#39;: 2, &#39;ZX&#39;: 2, &#39;X&#39;: 1, &#39;Y&#39;: 1, &#39;Z&#39;: 1}[direction]</span>
<span class="c1">#             suffix = &#39;&#39; if direction == &#39;XYZ&#39; else f&#39;_{direction}&#39;</span>
<span class="c1">#             posit = conduct_rectified_structure_array[direction_idx, :, :, :]</span>
<span class="c1">#             step_counts = len(posit[0, :, 0])</span>

<span class="c1">#             print(f&quot;posit shape for NGP: {posit.shape}&quot;)</span>
<span class="c1">#             print(f&quot;step_counts for NGP: {step_counts}&quot;)</span>

<span class="c1">#             num_mobile_ions = posit.shape[0]</span>
<span class="c1">#             # Parallel calculation of NGP for all ions</span>
<span class="c1">#             with Pool() as pool:</span>
<span class="c1">#                 ngp_ions = pool.starmap(calc_ngp_tracer, </span>
<span class="c1">#                                        [(posit[i, :, :], d, d_idx) for i in range(num_mobile_ions)])</span>
<span class="c1">#             ngp_ions = np.array(ngp_ions)</span>
<span class="c1">#             ngp_array = np.average(ngp_ions, axis=0)</span>

<span class="c1">#             print(f&quot;NGP array length: {len(ngp_array)}&quot;)</span>
<span class="c1">#             print(f&quot;dt length for NGP: {len(dt)}&quot;)</span>

<span class="c1">#             key_ngp = f&quot;NGP_array{suffix}&quot;</span>
<span class="c1">#             result_dict[element].setdefault(key_ngp, []).append(ngp_array)</span>
<span class="c1">#             result_dict[element].setdefault(&#39;time_lags&#39; + suffix, []).append(time_lags[mask])</span>

<span class="c1">#     return result_dict</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Vinay Maithani.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>